import re
from post.models import Post, Tag, PostTag
import urllib
from django.http import HttpResponse

#Pre query processing to generate sets with tags to be added and tags to be removes
def strip_query(query):
    #Set tag query pattern
    #tag_re = re.compile(r'[+|-]?\s*?#[\w|-]+')
    """
        Thought about this in the shower just now, this should be the RegEx
        that we're looking for that strips hash-tags out the way that we
        define them to be and combines the +/- signs to the next nearest
        hashtag.

        Feel free to list more test cases, or try to break the RegEx so that
        we can improve on it further :)

        Test cases:
            #ivan-#monica                       Output: ['#ivan', '-#monica']
            #ivan-here-there-#school            Output: ['#ivan-here-there', '-#school']
            #ivan--here-#monica                 Output: ['#ivan', '-#monica']
            #ivan-here-- there - - #school      Output: ['#ivan-here', '- #school']
            +  #ivan-here-there-- - + #school   Output: ['+  #ivan-here-there', '+ #school']
    """
    tag_re = re.compile(r'[+|-]?\s*#(?:\w|(?<=\w)-(?=\w))+') 
    s = query
    poststr = s
            
    #Initialize addset and removeset, to store tags
    # query='#a +#b-#c'
    # addset = ['a','b']; removeset = ['c']
    addset = set()
    removeset = set()

    #Find all tags
    tags = tag_re.findall(s)

    #Iterate each tags in query
    for tag in tags:
        # Don't think we need this any longer, the RegEx above took care of this
        # take out trailing '-' if it exists
        #if tag[len(tag) - 1] == '-':
        #    tag = tag[:-1]

        #if open with '+' add to addlist
        if tag[0] == '+':
            addset.add(tag[1:].strip()[1:])
        #elif open with '-' add to removelist
        elif tag[0] == '-':
            removeset.add(tag[1:].strip()[1:])
        #else, by default, open with word add to add list
        else:
            addset.add(tag.strip()[1:])

        #Original string reduced by all matched tags, for testing if valid input
        #Replace only the first occurance of matching tag
        poststr = poststr.replace(tag, '', 1)

    return addset, removeset, poststr.strip() == ''

"""
Function that returns posts based on the addset (tags to look for)
removeset (tags to remove from the found posts). The limit determines
how many posts should be returned.

Parameters:
    addset: tags that should be added together
    removeset: tags that should be removed
    limit: top number of posts that should be returned

Return values:
    posts: list of Post objects that are found
    ERR_MSG: error message generated by the function
"""
def getposts(addset, removeset, limit):
    """
    Cases:
    
    1) #ivan - #ivan - #school
    Output: [], ERR_MSG -> Nothing to subtract from

    2) #qirong
    Output: [], ERR_MSG -> No such tag found

    3) #qirong - #school
    Output: [], ERR_MSG -> Nothing to subtract from

    4) #qirong + #ivan - #school
    Output: [ << top 10 #ivan - #school >> ], ERR_MSG -> 'Tag(s) not found: qirong'
    """
    # Local Variables
    offset = 0
    pids = set()
    ERR_MSG = ''
    invalid_tags = []
    posts = [] # Return Post objects as the results
    
    # Error check: Empty Query: nothing in addset and removeset
    if not addset and not removeset:
        return [], "Nothing in addset or removeset."

    # Sanitize: Remove all invalid tags in addset and append to error message
    for tag in set(addset):
        try:
            Tag.objects.get(value=tag)
        except Exception:
            invalid_tags.append(tag)
            addset.remove(tag)

    # Generate error message
    if invalid_tags:
        ERR_MSG = "Tag(s) not found: {0}".format(", ".join(invalid_tags))

    # Case 0: #qirong - #school (Nothing in addset that is left, hence nothing to remove as well)
    # return: empty list with error message as well
    if not addset and invalid_tags:
        return [], ERR_MSG
    
    # ***
    # Accumulated post post_result[]
    post_results = []

    # Flag for empty_result set
    empty_results = False

    # Compile RegEx pattern if there are things in removeset
    if removeset:
        remove_regex = "|".join(removeset)
        pattern = re.compile('#({0})'.format(remove_regex))

    # Iterate to get posts
    while len(post_results) < limit and not empty_results:
        # If no addset items, get recent limit number of posts 
        if not addset:
            # Get limit most recent posts
            posts = Post.objects.all().order_by('-id')[offset:offset + limit]

            # Ensure we still have results to process
            if not posts:
                empty_results = True
                continue
        else:
            # Re-initialize pids set
            pids = set()

            # Get limit number of posts for each tags
            for tag in addset:
                posttag_set = Tag.objects.get(value=tag).posttag_set.all().order_by('-pid')[offset:offset + limit]

                # Union add the new found pids
                pids = pids.union({ pt.pid_id for pt in posttag_set })  

            if not len(pids):
                empty_results = True
                continue

            # Get all posts in the pids set
            posts = Post.objects.filter(id__in=pids) 
               
        # If there are tags to remove, remove them
        if removeset:
            # Remove post that have tags that are present in post.text
            for post in posts:
                if not pattern.findall(post.text):
                    post_results.append(post)
        else:
            post_results = list(posts)

        # Increment offset to get next set of posts
        offset += limit

    #Order posts by id descendingly    
    post_results = sorted(post_results, key=lambda post: -post.id)

    # Get limit number of posts
    post_results = post_results[:limit]

    # Return posts
    return post_results, ERR_MSG


def json_get(request, dest_url):
    if request.method == 'POST' and request.POST.dict().has_key('query'):
        query = request.POST.get('query', '')

        params = urllib.urlencode(dict(query=query))

        f = urllib.urlopen(dest_url, params)
        reply = '';

        for line in f:
            reply += line

        f.close()

    return HttpResponse(reply, content_type="application/json")



