import re
from post.models import Post, Tag, PostTag
from cassandra.cluster import Cluster

#Pre query processing to generate sets with tags to be added and tags to be removes
def strip_query(query):
    #Set tag query pattern
    #tag_re = re.compile(r'[+|-]?\s*?#[\w|-]+')
    """
        Thought about this in the shower just now, this should be the RegEx
        that we're looking for that strips hash-tags out the way that we
        define them to be and combines the +/- signs to the next nearest
        hashtag.

        Feel free to list more test cases, or try to break the RegEx so that
        we can improve on it further :)

        Test cases:
            #ivan-#monica                       Output: ['#ivan', '-#monica']
            #ivan-here-there-#school            Output: ['#ivan-here-there', '-#school']
            #ivan--here-#monica                 Output: ['#ivan', '-#monica']
            #ivan-here-- there - - #school      Output: ['#ivan-here', '- #school']
            +  #ivan-here-there-- - + #school   Output: ['+  #ivan-here-there', '+ #school']
    """
    tag_re = re.compile(r'[+|-]?\s*#(?:\w|(?<=\w)-(?=\w))+') 
    s = query
    poststr = s
            
    #Initialize addset and removeset, to store tags
    # query='#a +#b-#c'
    # addset = ['a','b']; removeset = ['c']
    addset = set()
    removeset = set()

    #Find all tags
    tags = tag_re.findall(s)

    #Iterate each tags in query
    for tag in tags:
        # Don't think we need this any longer, the RegEx above took care of this
        # take out trailing '-' if it exists
        #if tag[len(tag) - 1] == '-':
        #    tag = tag[:-1]

        #if open with '+' add to addlist
        if tag[0] == '+':
            addset.add(tag[1:].strip()[1:])
        #elif open with '-' add to removelist
        elif tag[0] == '-':
            removeset.add(tag[1:].strip()[1:])
        #else, by default, open with word add to add list
        else:
            addset.add(tag.strip()[1:])

        #Original string reduced by all matched tags, for testing if valid input
        #Replace only the first occurance of matching tag
        poststr = poststr.replace(tag, '', 1)

    return addset, removeset, poststr.strip() == ''
"""
#Get top 'topcnt' recent posts from addset and removeset
def getposts(oriadd,oriremove, topcnt):
    # Preprocessing of addset and removeset
    addset = oriadd - oriremove
    removeset = oriremove - oriadd
    
    # Check for addtag existence before retrieving posts
    for tag in addset:
        try:
            Tag.objects.get(value=tag)
        except Exception:
            addset.remove(tag)


    # Initialization of output:clean_posts and count value of post retrieval offset: cnt
    cnt = 0
    clean_posts = []  

    # Remove posts with tag from removeset
    if removeset:
        remove_str = "|".join(removeset)
        pattern = re.compile('#({0})'.format(remove_str))

    while len(clean_posts) < topcnt:
        pids = set()
        
        # Judge if addset is empty, set post_results from top ten, no matter what tag
        if not addset:
            post_results = Post.objects.all().order_by('-id')[cnt:cnt+topcnt]
        
        # if addset is not empty, retrieve top posts with corresponding tags    
        else:
            # Retrieve top cnt to cnt+topcnt from each addtag
            for addtag in addset:
                pts = Tag.objects.get(value=addtag).posttag_set.all().order_by('-pid')[cnt:cnt+topcnt]
                pids = pids.union({ps.pid_id for ps in pts})
            post_results = Post.objects.filter(id__in=pids) 
        
        #Order posts by id descendingly    
        post_results = sorted(post_results, key=lambda post: -post.id)
            
        #Remove post if removeset is not empty
        if removeset:
            for post in post_results:
                if not pattern.findall(post.text):
                    clean_posts.append(post)
        else:
            clean_posts = post_results

        #Add cnt for next round of data retrieval
        cnt = cnt+ topcnt
       
    return clean_posts[:topcnt]
"""

"""
Function that returns posts based on the addset (tags to look for)
removeset (tags to remove from the found posts). The limit determines
how many posts should be returned.

Parameters:
    addset: tags that should be added together
    removeset: tags that should be removed
    limit: top number of posts that should be returned

Return values:
    posts: list of Post objects that are found
    ERR_MSG: error message generated by the function
"""
def getposts(addset, removeset, limit):
    """
    Cases:
    
    1) #ivan - #ivan - #school
    Output: [], ERR_MSG -> Nothing to subtract from

    2) #qirong
    Output: [], ERR_MSG -> No such tag found

    3) #qirong - #school
    Output: [], ERR_MSG -> Nothing to subtract from

    4) #qirong + #ivan - #school
    Output: [ << top 10 #ivan - #school >> ], ERR_MSG -> 'Tag(s) not found: qirong'
    """
    # Local Variables
    offset = 0
    pids = set()
    ERR_MSG = ''
    invalid_tags = []
    posts = [] # Return Post objects as the results
    
    # Error check: Empty Query: nothing in addset and removeset
    if not addset and not removeset:
        return [], "Nothing in addset or removeset."

    # Sanitize: Remove all invalid tags in addset and append to error message
    for tag in set(addset):
        try:
            Tag.objects.get(value=tag)
        except Exception:
            invalid_tags.append(tag)
            addset.remove(tag)

    # Generate error message
    if invalid_tags:
        ERR_MSG = "Tag(s) not found: {0}".format(", ".join(invalid_tags))

    # Case 0: #qirong - #school (Nothing in addset that is left, hence nothing to remove as well)
    # return: empty list with error message as well
    if not addset and invalid_tags:
        return [], ERR_MSG

    # Case 1: #ivan #school (No tags to remove)
    if addset and not removeset:
        # Get limit number of posts for each set, merge them down to remove duplicates
        # and sort them in descending order by post.id (since we want most recent first)
        for tag in addset:
            posttag_set = Tag.objects.get(value=tag).posttag_set.all().order_by('-pid')[offset:offset + limit]
            pids = pids.union({ pt.pid_id for pt in posttag_set })

        # Get all posts to be returned
        posts = Post.objects.filter(id__in=pids) 

        #Order posts by id descendingly    
        posts = sorted(posts, key=lambda post: -post.id)

        # Get limit number of posts
        posts = posts[:limit]

        # Return posts
        return posts, ERR_MSG

    # Case 2: -#school (No add set, just remove set)
    # Case 3: #ivan - #school (add set and remove set not empty)
    elif not addset and removeset:
        print "case 2"
        # Compile RegEx pattern
        remove_regex = "|".join(removeset)
        pattern = re.compile('#({0})'.format(remove_regex))

        # Accumulated post post_result[]
        post_results = []

        # Flag for empty_result set
        empty_results = False

        # Iterate to get posts
        while len(post_results) < limit and not empty_results:
            # Differentiate between case 2 and 3
            # Case 2: -#school (No add set, just remove set)
            if not addset:
                # Get limit most recent posts
                posts = Post.objects.all().order_by('-id')[offset:offset + limit]

            # Case 3: addset has conten, serch for tagges posts by offset
            else:
                for tag in addset:
                    posttag_set = Tag.objects.get(value=tag).posttag_set.all().order_by('-pid')[offset:offset + limit]
                    pids = pids.union({ pt.pid_id for pt in posttag_set })

                # Get all posts in the pids set
                posts = Post.objects.filter(id__in=pids) 
            
            # Ensure we still have results to process
            if not posts:
                empty_results = True
                continue

            # Convert to list of posts
            posts = list(posts)

            # Remove post that have tags that are present in post.text
            for post in posts:
                if not pattern.findall(post.text):
                    post_results.append(post)

            # Increment offset to get next set of posts
            offset += limit

        #Order posts by id descendingly    
        post_results = sorted(post_results, key=lambda post: -post.id)

        # Get limit number of posts
        post_results = post_results[:limit]

        # Return posts
        return post_results, ERR_MSG

#*************************************
# Getting Post from Cassandra db
def getposts_ca(addset, removeset, limit):
    """
    Cases:
    
    1) #ivan - #ivan - #school
    Output: [], ERR_MSG -> Nothing to subtract from

    2) #qirong
    Output: [], ERR_MSG -> No such tag found

    3) #qirong - #school
    Output: [], ERR_MSG -> Nothing to subtract from

    4) #qirong + #ivan - #school
    Output: [ << top 10 #ivan - #school >> ], ERR_MSG -> 'Tag(s) not found: qirong'
    """
    # Connect to Cassandra Database
    cluster = Cluster(['localhost'])
    session = cluster.connect('hash_space')    
 
    # Local Variables
    offset = 0
    pids = set()
    ERR_MSG = ''
    invalid_tags = []
    posts = [] # Return Post objects as the results

    # Error check: Empty Query: nothing in addset and removeset
    if not addset and not removeset:
        return [], "Nothing in addset or removeset."

    # Sanitize: Remove all invalid tags in addset and append to error message
    for tag in set(addset):
        try:
            # Get tag count
            result = session.execute("SELECT count(*) from post_tag where tagtext=\'"+tag+"\' limit 10")
            count = result[0].count
            # if count==0, invalid tag query:    
            if count==0:
                invalid_tags.append(tag)
                addset.remove(tag)
        # if retrival of tag fails: invalid query
        except Exception:
            invalid_tags.append(tag)
            addset.remove(tag)

    # Generate error message
    if invalid_tags:
        ERR_MSG = "Tag(s) not found: {0}".format(", ".join(invalid_tags))

    # Case 0: #qirong - #school (Nothing in addset that is left, hence nothing to remove as well)
    # return: empty list with error message as well
    if not addset and invalid_tags:
        return [], ERR_MSG

    # Case 1: #ivan #school (No tags to remove)
    if addset and not removeset:
        # Get limit number of posts for each set, merge them down to remove duplicates
        # and sort them in descending order by post.id (since we want most recent first)
        for tag in addset:
            # Get list of pids with tag in addset, trim with offset` 
            pids=session.execute("select postid from post_tag where tagtext=\'"+tag+"\' order by postid desc limit "+str(limit))
            pids=[p.postid for p in pids]
            pids=pids[offset:offset+limit]

        print "Cassandra get all pids: ", pids
        # Get all posts to be returned
        # Using MySQL to retrieve post texts
        posts = Post.objects.filter(id__in=pids) 

        #Order posts by id descendingly    
        posts = sorted(posts, key=lambda post: -post.id)

        # Get limit number of posts
        posts = posts[:limit]

        # Return posts
        return posts, ERR_MSG

    # Case 2: -#school (No add set, just remove set)
    # Case 3: #ivan - #school (add set and remove set not empty)
    elif removeset:
        print "case 2"
        # Compile RegEx pattern
        remove_regex = "|".join(removeset)
        pattern = re.compile('#({0})'.format(remove_regex))

        # Accumulated post post_result[]
        post_results = []

        # Flag for empty_result set
        empty_results = False

        # Iterate to get posts
        while len(post_results) < limit and not empty_results:
            # Differentiate between case 2 and 3
            # Case 2: -#school (No add set, just remove set)
            if not addset:
                # Get limit most recent posts
                # Question about Cassandra joining: Replace with Cassandra code
                posts = Post.objects.all().order_by('-id')[offset:offset + limit]

            # Case 3: addset has conten, serch for tagges posts by offset
            else:
                for tag in addset:
                    # Get list of pids with tag in addset in desc order, trim with offset` 
                    pids=session.execute("select postid from post_tag where tagtext=\'"+tag+"\' order by postid desc limit "+str(limit))
                    pids=[p.postid for p in pids]
                    pids=pids[offset:offset+limit]

                # Get all posts in the pids set
                posts = Post.objects.filter(id__in=pids) 
            
            # Ensure we still have results to process
            if not posts:
                empty_results = True
                continue

            # Convert to list of posts
            posts = list(posts)

            # Remove post that have tags that are present in post.text
            for post in posts:
                if not pattern.findall(post.text):
                    post_results.append(post)

            # Increment offset to get next set of posts
            offset += limit

        # Replace with Cassandra code
        #Order posts by id descendingly    
        post_results = sorted(post_results, key=lambda post: -post.id)

        # Get limit number of posts
        post_results = post_results[:limit]

        # Return posts
        return post_results, ERR_MSG
"""
# Preprocessing of addset and removeset
addset = oriadd - oriremove
removeset = oriremove - oriadd

# Check for addtag existence before retrieving posts
for tag in addset:
    try:
        Tag.objects.get(value=tag)
    except Exception:
        addset.remove(tag)


# Initialization of output:clean_posts and count value of post retrieval offset: cnt
cnt = 0
clean_posts = []  

# Remove posts with tag from removeset
if removeset:
    remove_str = "|".join(removeset)
    pattern = re.compile('#({0})'.format(remove_str))

while len(clean_posts) < topcnt:
    pids = set()
    
    # Judge if addset is empty, set post_results from top ten, no matter what tag
    if not addset:
        post_results = Post.objects.all().order_by('-id')[cnt:cnt+topcnt]
    
    # if addset is not empty, retrieve top posts with corresponding tags    
    else:
        # Retrieve top cnt to cnt+topcnt from each addtag
        for addtag in addset:
            pts = Tag.objects.get(value=addtag).posttag_set.all().order_by('-pid')[cnt:cnt+topcnt]
            pids = pids.union({ps.pid_id for ps in pts})
        post_results = Post.objects.filter(id__in=pids) 
    
    #Order posts by id descendingly    
    post_results = sorted(post_results, key=lambda post: -post.id)
        
    #Remove post if removeset is not empty
    if removeset:
        for post in post_results:
            if not pattern.findall(post.text):
                clean_posts.append(post)
    else:
        clean_posts = post_results

    #Add cnt for next round of data retrieval
    cnt = cnt+ topcnt
   
return clean_posts[:topcnt]
"""
